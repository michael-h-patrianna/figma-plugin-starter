import { useCallback, useEffect, useRef } from 'preact/hooks';

/**
 * Configuration for message handlers in the plugin communication hook.
 */
interface MessageHandlers {
  /** Handler for all message types from the main thread */
  onMessage: (type: string, data: any) => void;
}

/**
 * Custom hook for handling bidirectional communication between the Figma plugin UI and main thread.
 *
 * This hook provides a flexible message handling system that can be extended for different
 * plugin communication patterns. It manages message listeners and provides functions
 * to send commands back to the main thread.
 *
 * @param handlers - Object containing message handler function for all message types
 * @returns Object containing functions to send messages to the main thread
 *
 * @example
 * ```tsx
 * // Basic usage handling scan and process operations
 * const { sendMessage } = usePluginMessages({
 *   onMessage: (type, data) => {
 *     switch(type) {
 *       case 'SCAN_RESULT':
 *         console.log('Scan completed:', data);
 *         break;
 *       case 'PROCESS_RESULT':
 *         console.log('Process completed:', data);
 *         break;
 *       case 'SCAN_PROGRESS':
 *         setProgress(data); // data is the progress value for SCAN_PROGRESS
 *         break;
 *       default:
 *         console.log('Unknown message type:', type, data);
 *     }
 *   }
 * });
 *
 * // Extended usage with custom message types
 * const { sendMessage } = usePluginMessages({
 *   onMessage: (type, data) => {
 *     switch(type) {
 *       case 'SCAN_RESULT': handleScanResult(data); break;
 *       case 'PROCESS_RESULT': handleProcessResult(data); break;
 *       case 'SCAN_PROGRESS': setProgress(data); break;
 *       case 'CUSTOM_ACTION': handleCustomAction(data); break;
 *       case 'STATUS_UPDATE': updateStatus(data); break;
 *       default: console.log('Unhandled message:', type, data);
 *     }
 *   }
 * });
 *
 * // Send messages
 * sendMessage('SCAN'); // Trigger a scan operation
 * sendMessage('PROCESS', { action: 'export', format: 'json' }); // Process with data
 * sendMessage('CUSTOM_ACTION', { param: 'value' }); // Custom message
 * ```
 */
export function usePluginMessages(handlers: MessageHandlers) {
  const { onMessage } = handlers;

  // Use a ref to store the latest onMessage function to avoid recreating listeners
  const onMessageRef = useRef(onMessage);
  onMessageRef.current = onMessage;

  useEffect(() => {
    /**
     * Handles incoming messages from the Figma plugin main thread.
     *
     * Processes different message types and routes them to the message handler.
     *
     * @param event - The message event from the main thread containing plugin message data
     */
    function handleMessage(event: MessageEvent) {
      console.log('游댯 handleMessage ENTRY:', {
        eventData: event.data,
        eventOrigin: event.origin,
        eventSource: event.source,
        timestamp: new Date().toISOString()
      });


      try {
        // Handle both wrapped and direct message formats for compatibility
        let messageType, messageData;

        if (event.data.pluginMessage) {
          // New format: { pluginMessage: { type, data, progress } }
          const { type, data, progress } = event.data.pluginMessage;
          messageType = type;
          messageData = data; // Always use data field
          console.log('游릭 handleMessage PARSED (new format):', {
            messageType,
            messageData,
            progress,
            dataType: typeof messageData,
            dataSize: JSON.stringify(messageData)?.length || 0
          });
        } else if (event.data.type) {
          // Original format: { type, data, progress }
          const { type, data, progress } = event.data;
          messageType = type;
          messageData = data; // Always use data field
          console.log('游릭 handleMessage PARSED (original format):', {
            messageType,
            messageData,
            progress,
            dataType: typeof messageData,
            dataSize: JSON.stringify(messageData)?.length || 0
          });
        } else {
          console.log('游리 handleMessage IGNORED (not plugin message):', event.data);
          return; // Not a plugin message
        }

        console.log('游릮 handleMessage CALLING onMessageRef.current with:', {
          messageType,
          messageData,
          handlerExists: typeof onMessageRef.current === 'function'
        });

        try {
          // Create a minimal function call to avoid any potential memory issues
          const handler = onMessageRef.current;
          if (typeof handler === 'function') {
            handler(messageType, messageData);
            console.log('游릭 handleMessage onMessageRef.current call succeeded for type:', messageType);
          } else {
            console.log('游리 handleMessage no handler function available');
          }
        } catch (handlerError) {
          console.error('游댮 handleMessage ERROR in onMessageRef.current call:', handlerError);
          console.error('游댮 handleMessage ERROR messageType:', messageType);
          console.error('游댮 handleMessage ERROR messageData:', messageData);
          return; // Exit early if handler fails
        }

        console.log('游릭 handleMessage COMPLETED successfully for type:', messageType);
      } catch (error) {
        console.error('游댮 handleMessage ERROR:', error);
        console.error('游댮 handleMessage ERROR event.data:', event.data);
      }
    }

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, []); // Empty dependency array - listener is stable

  /**
   * Sends a message to the main thread with custom type and data.
   *
   * Allows for flexible communication patterns for any plugin operation.
   * Includes throttling to prevent overwhelming Figma's message system.
   *
   * @param type - The message type identifier
   * @param data - Optional data payload to send with the message
   */
  const sendMessage = useCallback((type: string, data?: any) => {
    console.log('游댯 sendMessage ENTRY:', {
      type,
      data,
      dataType: typeof data,
      dataSize: data ? JSON.stringify(data)?.length || 0 : 0,
      timestamp: new Date().toISOString()
    });

    try {
      // Use direct format to match main thread expectations
      const messagePayload = { pluginMessage: { type, data } };

      console.log('游릭 sendMessage CALLING parent.postMessage with:', {
        messagePayload,
        payloadSize: JSON.stringify(messagePayload)?.length || 0
      });

      parent.postMessage(messagePayload, '*');

      console.log('游릭 sendMessage COMPLETED successfully for type:', type);
    } catch (error) {
      console.error('游댮 sendMessage ERROR:', error);
      console.error('游댮 sendMessage ERROR type:', type);
      console.error('游댮 sendMessage ERROR data:', data);
    }
  }, []);

  return { sendMessage };
}
